#!/usr/bin/env bash

set -x

poweron() {
  rfkill unblock bluetooth
  notify-send "BT: $(bluetoothctl power on)"
}

poweroff() {
  notify-send "BT: $(bluetoothctl power off)"
  rfkill block bluetooth
}

discover() {
  trap cleanup SIGHUP SIGINT SIGQUIT SIGABRT SIGKILL SIGTERM
  # the discover task may be spawned headless.
  # save the PID of this execution in the tmp filename. 
  # used to kill all running procs in `cleanup.
  touch /tmp/bt.script.procs.$$

  # spawn bluetoothctl and also record it's pid.
  coproc btctl { bluetoothctl > /tmp/btctl.out; } 
  touch /tmp/bt.script.procs.ctl.$btctl_PID
  #sleep 1
  #notify-send "PID of btctl: ${btctl_PID}"

  # Issue command to coproc
  echo -e "scan on" >&${btctl[1]}

  # pipe the output of the coproc to notify-send
  # Caution: runs forever, until the script is terminated or cleanup is called.
  # sed -u: unbuffered.
  tail -f /tmp/btctl.out | grep --line-buffered NEW |  sed -u "s/.*Device\ [^\ ]*\ //g" | sed -u "s/^/BT: Device discovered: /g" | xargs -I {} notify-send {}; 
}

cleanup() {
  for file in /tmp/bt.script.procs.*; do
    pid=$(echo $file | sed 's/[^0-9]*//g')
    if [ "$pid" != $$ ]; then
      notify-send "BT: [cleanup] Killing PID $pid"
      rm $file
      kill -9 $pid 
    fi
  done;
  rm /tmp/btctl.out
  rm /tmp/bt.script.procs.$$
}

process() {
  poweron
  coproc dscvr { discover; }
  touch /tmp/bt.script.procs.$dscvr_PID

  # chose a device
  while true; do
    sleep 1
    choice=$(echo -e "Refresh\n$(list | sort -d)\nCancel" | dmenu -l 5 -i -p "Chose device")
    case $choice in
      Refresh) continue ;;
      Cancel) cleanup && exit ;;
      *) break ;;
    esac
  done
  # DEBUG
  # notify-send "choice: $choice"
  
  # get back the MAC address
  echo -e "$choice" | cut -d'-' -f2
  while read line; do
    if echo -e $line | grep "$(echo -e "$choice" | cut -d'-' -f2)"; then
      mac=$(echo $line | cut -d' ' -f2)

    fi
  done <<< "$(bluetoothctl devices)"
  # DEBUG
  # notify-send "mac: $mac"


  # get process file descriptor
  #
  # TODO: fix.
  # Hack to get the pid of bluetoothctl. better extract from filename without the loop?
  for f in /tmp/bt.script.procs.ctl.*; do
    ctlpid=$(echo "$f" | sed 's/\/tmp\/bt.script.procs.ctl.//g')
    echo $ctlpid
  done

  # Issue the processing command
  echo -e "$1 $mac" >&/proc/$ctlpid/fd/0
  sleep 15

  cleanup
}

list () {
  case $1 in 
    connected) echo -e "$(bluetoothctl devices Connected)" && return ;;
    paired) echo -e "$(bluetoothctl devices Paired)" && return ;;
    trusted) echo  -e "$(bluetoothctl devices Trusted)" && return ;;
    *) ;;
  esac
  connected="$(list connected)"
  paired="$(list paired)"
  trusted="$(list trusted)"
  all="$(bluetoothctl devices)"

  out=""

  # This does not work because iterates words
  # for d in $paired; do
  #
  # This does not work because executed in subshell  when piping to read line
  # pattern: echo -e $lines | while read -r line

  # REF: https://www.baeldung.com/linux/while-loop-variable-scope
  # echo "$paired" | while IFS= read -r line; do

  while read line; do
    mac="$(echo $line | cut -d' ' -f2)"
    if [[ -n "$mac" ]]; then
      if echo -e "$all" | grep -q "$mac"; then
        all="$(echo -e "$all" | sed "s/.*Device $mac/CONNECTED -/g")"
      fi
    fi
  done <<< "$connected"

  while read line; do
    mac="$(echo $line | cut -d' ' -f2)"                                          
    if [[ -n "$mac" ]]; then
      if echo -e "$all" | grep -q "$mac"; then
        all="$(echo -e "$all" | sed "s/.*Device $mac/TRUSTED   -/g")"
      fi
    fi
  done <<< "$trusted"

  while read line; do
    mac="$(echo $line | cut -d' ' -f2)"                                           
    if [[ -n "$mac" ]]; then
      if echo -e "$all" | grep -q "$mac"; then
        all="$(echo -e "$all" | sed "s/.*Device $mac/PAIRED    -/g")"
      fi
    fi
  done <<< "$paired"

                                        
  all="$(echo -e "$all" |           sed "s/^Device [:0-9A-Z]*/VISIBLE   -/g")" 
  echo -e "$all"
}

what() {
  choice=$(echo -e "power on\npower off\nconnect\ndisconnect\ntrust\nunpair\ndiscover\nclean up" | dmenu -i -l 10 -p "Bluetooth Action: ")

  case $choice in
    power\ on) poweron ;;
    power\ off) poweroff ;;
    connect) process "connect" ;;
    disconnect) process "disconnect" ;; 
    trust) process "trust" ;;
    pair) process "pair" ;;
    unpair) process "remove" ;;
    clean\ up) cleanup ;;
    discover) discover ;;
    *) exit ;;
  esac
}

what
